/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT MODIFY */

/*
 * schema-defined QAPI visitor functions
 *
 * Copyright IBM, Corp. 2011
 *
 * Authors:
 *  Anthony Liguori   <aliguori@us.ibm.com>
 *
 * This work is licensed under the terms of the GNU LGPL, version 2.1 or later.
 * See the COPYING.LIB file in the top-level directory.
 *
 */

#include "qemu-common.h"
#include "test-qapi-visit.h"

void visit_type_EnumOneList(Visitor *m, EnumOneList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                EnumOneList *native_i = (EnumOneList *)i;
                visit_type_EnumOne(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_EnumOne(Visitor *m, EnumOne * obj, const char *name, Error **errp)
{
    visit_type_enum(m, (int *)obj, EnumOne_lookup, "EnumOne", name, errp);
}

static void visit_type_NestedEnumsOne_fields(Visitor *m, NestedEnumsOne ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_EnumOne(m, obj ? &(*obj)->enum1 : NULL, "enum1", &err);
    visit_start_optional(m, obj ? &(*obj)->has_enum2 : NULL, "enum2", &err);
    if (obj && (*obj)->has_enum2) {
        visit_type_EnumOne(m, obj ? &(*obj)->enum2 : NULL, "enum2", &err);
    }
    visit_end_optional(m, &err);
    visit_type_EnumOne(m, obj ? &(*obj)->enum3 : NULL, "enum3", &err);
    visit_start_optional(m, obj ? &(*obj)->has_enum4 : NULL, "enum4", &err);
    if (obj && (*obj)->has_enum4) {
        visit_type_EnumOne(m, obj ? &(*obj)->enum4 : NULL, "enum4", &err);
    }
    visit_end_optional(m, &err);

    error_propagate(errp, err);
}

void visit_type_NestedEnumsOne(Visitor *m, NestedEnumsOne ** obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        Error *err = NULL;
        visit_start_struct(m, (void **)obj, "NestedEnumsOne", name, sizeof(NestedEnumsOne), &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_NestedEnumsOne_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_NestedEnumsOneList(Visitor *m, NestedEnumsOneList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                NestedEnumsOneList *native_i = (NestedEnumsOneList *)i;
                visit_type_NestedEnumsOne(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

static void visit_type_UserDefOne_fields(Visitor *m, UserDefOne ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_int(m, obj ? &(*obj)->integer : NULL, "integer", &err);
    visit_type_str(m, obj ? &(*obj)->string : NULL, "string", &err);
    visit_start_optional(m, obj ? &(*obj)->has_enum1 : NULL, "enum1", &err);
    if (obj && (*obj)->has_enum1) {
        visit_type_EnumOne(m, obj ? &(*obj)->enum1 : NULL, "enum1", &err);
    }
    visit_end_optional(m, &err);

    error_propagate(errp, err);
}

void visit_type_UserDefOne(Visitor *m, UserDefOne ** obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        Error *err = NULL;
        visit_start_struct(m, (void **)obj, "UserDefOne", name, sizeof(UserDefOne), &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefOne_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefOneList(Visitor *m, UserDefOneList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefOneList *native_i = (UserDefOneList *)i;
                visit_type_UserDefOne(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

static void visit_type_UserDefTwo_dict_dict_fields(Visitor *m, UserDefTwo ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_UserDefOne(m, obj ? &(*obj)->dict.dict.userdef : NULL, "userdef", &err);
    visit_type_str(m, obj ? &(*obj)->dict.dict.string : NULL, "string", &err);

    error_propagate(errp, err);
}

static void visit_type_UserDefTwo_dict_dict2_fields(Visitor *m, UserDefTwo ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_UserDefOne(m, obj ? &(*obj)->dict.dict2.userdef : NULL, "userdef", &err);
    visit_type_str(m, obj ? &(*obj)->dict.dict2.string : NULL, "string", &err);

    error_propagate(errp, err);
}

static void visit_type_UserDefTwo_dict_fields(Visitor *m, UserDefTwo ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_str(m, obj ? &(*obj)->dict.string : NULL, "string", &err);
    if (!error_is_set(errp)) {
        Error **errp = &err; /* from outer scope */
        Error *err = NULL;
        visit_start_struct(m, NULL, "", "dict", 0, &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefTwo_dict_dict_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
    visit_start_optional(m, obj ? &(*obj)->dict.has_dict2 : NULL, "dict2", &err);
    if (obj && (*obj)->dict.has_dict2) {
        if (!error_is_set(errp)) {
            Error **errp = &err; /* from outer scope */
            Error *err = NULL;
            visit_start_struct(m, NULL, "", "dict2", 0, &err);
            if (!err) {
                if (!obj || *obj) {
                    visit_type_UserDefTwo_dict_dict2_fields(m, obj, &err);
                    error_propagate(errp, err);
                    err = NULL;
                }
                /* Always call end_struct if start_struct succeeded.  */
                visit_end_struct(m, &err);
            }
            error_propagate(errp, err);
        }
    }
    visit_end_optional(m, &err);

    error_propagate(errp, err);
}

static void visit_type_UserDefTwo_fields(Visitor *m, UserDefTwo ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_str(m, obj ? &(*obj)->string : NULL, "string", &err);
    if (!error_is_set(errp)) {
        Error **errp = &err; /* from outer scope */
        Error *err = NULL;
        visit_start_struct(m, NULL, "", "dict", 0, &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefTwo_dict_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }

    error_propagate(errp, err);
}

void visit_type_UserDefTwo(Visitor *m, UserDefTwo ** obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        Error *err = NULL;
        visit_start_struct(m, (void **)obj, "UserDefTwo", name, sizeof(UserDefTwo), &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefTwo_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefTwoList(Visitor *m, UserDefTwoList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefTwoList *native_i = (UserDefTwoList *)i;
                visit_type_UserDefTwo(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

static void visit_type_UserDefNested_dict1_dict2_fields(Visitor *m, UserDefNested ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_UserDefOne(m, obj ? &(*obj)->dict1.dict2.userdef1 : NULL, "userdef1", &err);
    visit_type_str(m, obj ? &(*obj)->dict1.dict2.string2 : NULL, "string2", &err);

    error_propagate(errp, err);
}

static void visit_type_UserDefNested_dict1_dict3_fields(Visitor *m, UserDefNested ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_UserDefOne(m, obj ? &(*obj)->dict1.dict3.userdef2 : NULL, "userdef2", &err);
    visit_type_str(m, obj ? &(*obj)->dict1.dict3.string3 : NULL, "string3", &err);

    error_propagate(errp, err);
}

static void visit_type_UserDefNested_dict1_fields(Visitor *m, UserDefNested ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_str(m, obj ? &(*obj)->dict1.string1 : NULL, "string1", &err);
    if (!error_is_set(errp)) {
        Error **errp = &err; /* from outer scope */
        Error *err = NULL;
        visit_start_struct(m, NULL, "", "dict2", 0, &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefNested_dict1_dict2_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
    visit_start_optional(m, obj ? &(*obj)->dict1.has_dict3 : NULL, "dict3", &err);
    if (obj && (*obj)->dict1.has_dict3) {
        if (!error_is_set(errp)) {
            Error **errp = &err; /* from outer scope */
            Error *err = NULL;
            visit_start_struct(m, NULL, "", "dict3", 0, &err);
            if (!err) {
                if (!obj || *obj) {
                    visit_type_UserDefNested_dict1_dict3_fields(m, obj, &err);
                    error_propagate(errp, err);
                    err = NULL;
                }
                /* Always call end_struct if start_struct succeeded.  */
                visit_end_struct(m, &err);
            }
            error_propagate(errp, err);
        }
    }
    visit_end_optional(m, &err);

    error_propagate(errp, err);
}

static void visit_type_UserDefNested_fields(Visitor *m, UserDefNested ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_str(m, obj ? &(*obj)->string0 : NULL, "string0", &err);
    if (!error_is_set(errp)) {
        Error **errp = &err; /* from outer scope */
        Error *err = NULL;
        visit_start_struct(m, NULL, "", "dict1", 0, &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefNested_dict1_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }

    error_propagate(errp, err);
}

void visit_type_UserDefNested(Visitor *m, UserDefNested ** obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        Error *err = NULL;
        visit_start_struct(m, (void **)obj, "UserDefNested", name, sizeof(UserDefNested), &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefNested_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefNestedList(Visitor *m, UserDefNestedList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefNestedList *native_i = (UserDefNestedList *)i;
                visit_type_UserDefNested(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

static void visit_type_UserDefA_fields(Visitor *m, UserDefA ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_bool(m, obj ? &(*obj)->boolean : NULL, "boolean", &err);

    error_propagate(errp, err);
}

void visit_type_UserDefA(Visitor *m, UserDefA ** obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        Error *err = NULL;
        visit_start_struct(m, (void **)obj, "UserDefA", name, sizeof(UserDefA), &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefA_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefAList(Visitor *m, UserDefAList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefAList *native_i = (UserDefAList *)i;
                visit_type_UserDefA(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

static void visit_type_UserDefB_fields(Visitor *m, UserDefB ** obj, Error **errp)
{
    Error *err = NULL;
    visit_type_int(m, obj ? &(*obj)->integer : NULL, "integer", &err);

    error_propagate(errp, err);
}

void visit_type_UserDefB(Visitor *m, UserDefB ** obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        Error *err = NULL;
        visit_start_struct(m, (void **)obj, "UserDefB", name, sizeof(UserDefB), &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefB_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefBList(Visitor *m, UserDefBList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefBList *native_i = (UserDefBList *)i;
                visit_type_UserDefB(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefUnionKind(Visitor *m, UserDefUnionKind * obj, const char *name, Error **errp)
{
    visit_type_enum(m, (int *)obj, UserDefUnionKind_lookup, "UserDefUnionKind", name, errp);
}

void visit_type_UserDefUnion(Visitor *m, UserDefUnion ** obj, const char *name, Error **errp)
{
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_struct(m, (void **)obj, "UserDefUnion", name, sizeof(UserDefUnion), &err);
        if (!err) {
            if (obj && *obj) {
                visit_type_UserDefUnionKind(m, &(*obj)->kind, "type", &err);
                if (!err) {
                    switch ((*obj)->kind) {
                    case USER_DEF_UNION_KIND_A:
                        visit_type_UserDefA(m, &(*obj)->a, "data", &err);
                        break;
                    case USER_DEF_UNION_KIND_B:
                        visit_type_UserDefB(m, &(*obj)->b, "data", &err);
                        break;
                    default:
                        abort();
                    }
                }
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefUnionList(Visitor *m, UserDefUnionList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefUnionList *native_i = (UserDefUnionList *)i;
                visit_type_UserDefUnion(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefNativeListUnionKind(Visitor *m, UserDefNativeListUnionKind * obj, const char *name, Error **errp)
{
    visit_type_enum(m, (int *)obj, UserDefNativeListUnionKind_lookup, "UserDefNativeListUnionKind", name, errp);
}

void visit_type_UserDefNativeListUnion(Visitor *m, UserDefNativeListUnion ** obj, const char *name, Error **errp)
{
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_struct(m, (void **)obj, "UserDefNativeListUnion", name, sizeof(UserDefNativeListUnion), &err);
        if (!err) {
            if (obj && *obj) {
                visit_type_UserDefNativeListUnionKind(m, &(*obj)->kind, "type", &err);
                if (!err) {
                    switch ((*obj)->kind) {
                    case USER_DEF_NATIVE_LIST_UNION_KIND_INTEGER:
                        visit_type_intList(m, &(*obj)->integer, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_S8:
                        visit_type_int8List(m, &(*obj)->s8, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_S16:
                        visit_type_int16List(m, &(*obj)->s16, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_S32:
                        visit_type_int32List(m, &(*obj)->s32, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_S64:
                        visit_type_int64List(m, &(*obj)->s64, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_U8:
                        visit_type_uint8List(m, &(*obj)->u8, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_U16:
                        visit_type_uint16List(m, &(*obj)->u16, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_U32:
                        visit_type_uint32List(m, &(*obj)->u32, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_U64:
                        visit_type_uint64List(m, &(*obj)->u64, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_NUMBER:
                        visit_type_numberList(m, &(*obj)->number, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_BOOLEAN:
                        visit_type_boolList(m, &(*obj)->boolean, "data", &err);
                        break;
                    case USER_DEF_NATIVE_LIST_UNION_KIND_STRING:
                        visit_type_strList(m, &(*obj)->string, "data", &err);
                        break;
                    default:
                        abort();
                    }
                }
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefNativeListUnionList(Visitor *m, UserDefNativeListUnionList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefNativeListUnionList *native_i = (UserDefNativeListUnionList *)i;
                visit_type_UserDefNativeListUnion(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}

static void visit_type_UserDefOptions_fields(Visitor *m, UserDefOptions ** obj, Error **errp)
{
    Error *err = NULL;
    visit_start_optional(m, obj ? &(*obj)->has_i64 : NULL, "i64", &err);
    if (obj && (*obj)->has_i64) {
        visit_type_intList(m, obj ? &(*obj)->i64 : NULL, "i64", &err);
    }
    visit_end_optional(m, &err);
    visit_start_optional(m, obj ? &(*obj)->has_u64 : NULL, "u64", &err);
    if (obj && (*obj)->has_u64) {
        visit_type_uint64List(m, obj ? &(*obj)->u64 : NULL, "u64", &err);
    }
    visit_end_optional(m, &err);
    visit_start_optional(m, obj ? &(*obj)->has_u16 : NULL, "u16", &err);
    if (obj && (*obj)->has_u16) {
        visit_type_uint16List(m, obj ? &(*obj)->u16 : NULL, "u16", &err);
    }
    visit_end_optional(m, &err);
    visit_start_optional(m, obj ? &(*obj)->has_i64x : NULL, "i64x", &err);
    if (obj && (*obj)->has_i64x) {
        visit_type_int(m, obj ? &(*obj)->i64x : NULL, "i64x", &err);
    }
    visit_end_optional(m, &err);
    visit_start_optional(m, obj ? &(*obj)->has_u64x : NULL, "u64x", &err);
    if (obj && (*obj)->has_u64x) {
        visit_type_uint64(m, obj ? &(*obj)->u64x : NULL, "u64x", &err);
    }
    visit_end_optional(m, &err);

    error_propagate(errp, err);
}

void visit_type_UserDefOptions(Visitor *m, UserDefOptions ** obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        Error *err = NULL;
        visit_start_struct(m, (void **)obj, "UserDefOptions", name, sizeof(UserDefOptions), &err);
        if (!err) {
            if (!obj || *obj) {
                visit_type_UserDefOptions_fields(m, obj, &err);
                error_propagate(errp, err);
                err = NULL;
            }
            /* Always call end_struct if start_struct succeeded.  */
            visit_end_struct(m, &err);
        }
        error_propagate(errp, err);
    }
}

void visit_type_UserDefOptionsList(Visitor *m, UserDefOptionsList ** obj, const char *name, Error **errp)
{
    GenericList *i, **prev = (GenericList **)obj;
    Error *err = NULL;

    if (!error_is_set(errp)) {
        visit_start_list(m, name, &err);
        if (!err) {
            for (; (i = visit_next_list(m, prev, &err)) != NULL; prev = &i) {
                UserDefOptionsList *native_i = (UserDefOptionsList *)i;
                visit_type_UserDefOptions(m, &native_i->value, NULL, &err);
            }
            error_propagate(errp, err);
            err = NULL;

            /* Always call end_list if start_list succeeded.  */
            visit_end_list(m, &err);
        }
        error_propagate(errp, err);
    }
}
