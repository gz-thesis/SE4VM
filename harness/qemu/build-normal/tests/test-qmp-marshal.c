/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT MODIFY */

/*
 * schema-defined QMP->QAPI command dispatch
 *
 * Copyright IBM, Corp. 2011
 *
 * Authors:
 *  Anthony Liguori   <aliguori@us.ibm.com>
 *
 * This work is licensed under the terms of the GNU LGPL, version 2.1 or later.
 * See the COPYING.LIB file in the top-level directory.
 *
 */

#include "qemu-common.h"
#include "qemu/module.h"
#include "qapi/qmp/qerror.h"
#include "qapi/qmp/types.h"
#include "qapi/qmp/dispatch.h"
#include "qapi/visitor.h"
#include "qapi/qmp-output-visitor.h"
#include "qapi/qmp-input-visitor.h"
#include "qapi/dealloc-visitor.h"
#include "test-qapi-types.h"
#include "test-qapi-visit.h"

#include "test-qmp-commands.h"

static void qmp_marshal_input_user_def_cmd(QDict *args, QObject **ret, Error **errp)
{
    (void)args;
    if (error_is_set(errp)) {
        goto out;
    }
    qmp_user_def_cmd(errp);

out:

    return;
}

static void qmp_marshal_input_user_def_cmd1(QDict *args, QObject **ret, Error **errp)
{
    QmpInputVisitor *mi;
    QapiDeallocVisitor *md;
    Visitor *v;
    UserDefOne * ud1a = NULL;

    mi = qmp_input_visitor_new_strict(QOBJECT(args));
    v = qmp_input_get_visitor(mi);
    visit_type_UserDefOne(v, &ud1a, "ud1a", errp);
    qmp_input_visitor_cleanup(mi);

    if (error_is_set(errp)) {
        goto out;
    }
    qmp_user_def_cmd1(ud1a, errp);

out:
    md = qapi_dealloc_visitor_new();
    v = qapi_dealloc_get_visitor(md);
    visit_type_UserDefOne(v, &ud1a, "ud1a", NULL);
    qapi_dealloc_visitor_cleanup(md);
    return;
}

static void qmp_marshal_output_user_def_cmd2(UserDefTwo * ret_in, QObject **ret_out, Error **errp)
{
    QapiDeallocVisitor *md = qapi_dealloc_visitor_new();
    QmpOutputVisitor *mo = qmp_output_visitor_new();
    Visitor *v;

    v = qmp_output_get_visitor(mo);
    visit_type_UserDefTwo(v, &ret_in, "unused", errp);
    if (!error_is_set(errp)) {
        *ret_out = qmp_output_get_qobject(mo);
    }
    qmp_output_visitor_cleanup(mo);
    v = qapi_dealloc_get_visitor(md);
    visit_type_UserDefTwo(v, &ret_in, "unused", NULL);
    qapi_dealloc_visitor_cleanup(md);
}

static void qmp_marshal_input_user_def_cmd2(QDict *args, QObject **ret, Error **errp)
{
    UserDefTwo * retval = NULL;
    QmpInputVisitor *mi;
    QapiDeallocVisitor *md;
    Visitor *v;
    UserDefOne * ud1a = NULL;
    UserDefOne * ud1b = NULL;

    mi = qmp_input_visitor_new_strict(QOBJECT(args));
    v = qmp_input_get_visitor(mi);
    visit_type_UserDefOne(v, &ud1a, "ud1a", errp);
    visit_type_UserDefOne(v, &ud1b, "ud1b", errp);
    qmp_input_visitor_cleanup(mi);

    if (error_is_set(errp)) {
        goto out;
    }
    retval = qmp_user_def_cmd2(ud1a, ud1b, errp);
    if (!error_is_set(errp)) {
        qmp_marshal_output_user_def_cmd2(retval, ret, errp);
    }

out:
    md = qapi_dealloc_visitor_new();
    v = qapi_dealloc_get_visitor(md);
    visit_type_UserDefOne(v, &ud1a, "ud1a", NULL);
    visit_type_UserDefOne(v, &ud1b, "ud1b", NULL);
    qapi_dealloc_visitor_cleanup(md);
    return;
}

static void qmp_init_marshal(void)
{
    qmp_register_command("user_def_cmd", qmp_marshal_input_user_def_cmd, QCO_NO_OPTIONS);
    qmp_register_command("user_def_cmd1", qmp_marshal_input_user_def_cmd1, QCO_NO_OPTIONS);
    qmp_register_command("user_def_cmd2", qmp_marshal_input_user_def_cmd2, QCO_NO_OPTIONS);
}

qapi_init(qmp_init_marshal);
